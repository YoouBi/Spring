import java.util.List;

public class Main {
	public static void main(String[] args) {
//		List<String> list; // 타입을 한 번 쓰면 이 String 타입이 고정되는 건 많이 봤을 것이다
		// 그럼 이 타입에 관계없이 유연하게 쓰려면 어떻게 해야할까?
		// 제네릭을 써야하는데 MyHolder.java에서 제네릭을 만들어보자
		MyHolder<String> h1 = new MyHolder<>("스트링값 가지는 객체");
		MyHolder<Integer> h2 = new MyHolder<>(199);
		
		MyPair<String, Integer> p1 = new MyPair<>("키값", 456);
		MyPair<String, String> p2 = new MyPair<>("스트링키", "스트링밸류");
		MyPair<String, MyPair<String, String>> p3;
		
		MyHolder h3 = new MyHolder(); // 빈 생성자로 제네릭 없이도 쓸 수 있다
//		h3.setO(o); // 그런데 안에 있는 메소드 세터게터를 보면 오브젝트로 동작하게 되어있다
		// 제네릭이 있는 타입이라 할지라도 제네릭을 안정해주면은 모든 것을 표현할 수 있는 오브젝트로 표현해준다
		// 그런데 동적인 타입을 쓰려고 만든거니까 이렇게 쓸 일은 없을 것
	}
}

// 연산의 흐름은 기억장치에 쭉 나열되어있을 것
// 이 기억장치라는 건 SSD/HD에 영구적으로 ...휘발성?
// 근데 이 장치들은 연산하는게 느리다
// 우리가 지금 사용하고 있는 CPU의 연산속도와 HD같은 입출구 연산속도는 어마어마하게 차이나서 병목현상이라는게 생긴다
// 이 정보들을 필요할 때 빠른 기억장치로 옮김, 복사해야한다
// 그걸 RAM이라고 한다(상대적으로 빠름, 그러나 휘발성을 가지고 있기 때문에 영원히 기억할 수 없어서 전기를 계속 공급해줘야한다)
// 그래서 전략을 짜보면 작업을 해야하는 데이터를 빠르게 RAM에서 읽고 쓴 다음에 SSD/HD
// 이렇게 쓰는게 파일 DB
// 상위 기억장치 캐쉬...도 있는데 그건 지금 공부 안함
// 아무튼 이러한 기억장치들의 공간은 무한하지 않기 때문에 새로운 하드를 달게 아니라면 계속해서 공간을 비워줘야하는데
// 메모리 매니지먼트를 프로그래머들이 직접했음(자원을 램 공간에서 쓰다가 다 쓰고나면 직접 지움)
// 개발자들도 실수를 하더라 자동으로 하게 만들자, 가 'G.C'
// JVM에서 다 쓴 자원을 알아서 지워주는 역할을 하는데
// 이 '다썼다'는 기준을 어떻게 잡아야할까?
// 공간을 쭉 객체로 활용을 하는데 이 객체는 참조변수로 참조를 한다
// 이 G.C라는 친구는 참조가 있으면 객체를 활용하고 있구나 하고 생각을 한다
// 그런데 만약 이 참조가 없는 객체가 있다면(스코프 해제) 그 객체를 접근이 불가능, 재사용이 불가능한 인스턴스가 되므로 쓰레기라고 생각해서 찾아서 지워버린다
// 그럼 G.C 얘네들이 실시간으로 일어나느냐?
// 이런 인스턴스들이 계속해서 만들어지고 옮겨지고 JVM에서 움직이고 있기 때문에
// 수정하려면 프로그램을 멈춰야한다(월드 스탑?)
// 모든 어플리케이션의 동작을 멈추고 쓰레기를 멈춘 다음에 재가동 시키는 것
// 월드 스탑으로 환경이 멈추기 때문에 C나 C++보다 느린 환경이 생기는데 이 기간을 짧게 만들어야함
// 등급을 매겨서 오래된 인스턴스일수록 나중에 살펴보거나 안살펴봐도 되고
// 새로 생성된 인스턴스들을 먼저 살펴봄
// 자바는 빠른 언어라 JVM을 쓰는 환경들이 만들어지는 것

// 오브젝트 클래스에 finalize라는 메소드가 있는데 이건 G.C가 해당 인스턴스를 쓰레기로 판별을하고 지우기 전에 호출을 한다
// 인스턴스의 마지막ㅠㅠ 죽기 전 유언ㅠㅠ으로 보통은 자원 해제 같은게 많이 들어간다
// 잘못하면 보안상 문제가 생길 수도 있기 때문에 쓸 때 유의하기